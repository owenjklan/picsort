#!/usr/bin/env python3
import os
import sys
import zipfile
from zipfile import is_zipfile

import click
import exif
from click import secho

from progbar import TextProgressBar


# Supported source types
ZIP_ARCHIVE_SRC = "zip"
DIRECTORY_SRC = "directory"
UNSUPPORTED_SRC = "unsupported"


def determine_source_type(image_source):
    # Fatal errors, like non-existant sources, will be reported and this
    # function will exit if necessary.
    if os.path.exists(image_source) is False:
        secho(f"Specified source, {image_source}, does not exist!",
              fg="red", bold=True, err=True)
        sys.exit(1)

    # Check if path is a directory
    if os.path.isdir(image_source) is True:
        return DIRECTORY_SRC

    # Be sure it is actually a regular file
    if os.path.isfile(image_source) is False:
        secho(f"Specified source, {image_source}, is not a regular file, or a"
              f" directory!", fg="red", bold=True, err=True)
        sys.exit(1)

    # Test if it is a valid ZIP file
    if is_zipfile(image_source) is True:
        return ZIP_ARCHIVE_SRC

    # Might be useful to return unsupported in future.
    secho(f"Specified source, {image_source}, is not a supported type!",
          fg="red", bold=True, err=True)
    sys.exit(1)


def sort_image_sources(source_list):
    directory_sources = []
    zip_archive_sources = []

    for image_source in source_list:
        image_source_path = os.path.abspath(image_source)
        image_source_type = determine_source_type(image_source_path)
        if image_source_type == ZIP_ARCHIVE_SRC:
            zip_archive_sources.append(image_source_path)
        elif image_source_type == DIRECTORY_SRC:
            directory_sources.append(image_source_path)
        else:  # Place holder for when other source types might be added.
            secho("Well, this is unexpected!")
            sys.exit(1)

    return directory_sources, zip_archive_sources


def file_path_is_jpeg(abs_file_path):
    if abs_file_path.lower().endswith(".jpg") is False:
        return False


def split_exif_date_string(exif_date_string):
    date_portion = exif_date_string.split(" ", 1)[0]
    year, month, day = date_portion.split(":")
    return year, month, day


def get_dates_from_zip_source(image_source):
    pass


def get_dates_from_directory_source(image_source):
    calculated_file_names = []

    for image_file_name in os.listdir(image_source):
        image_file_path = os.path.join(image_source, image_file_name)

        # Only JPEGs supported, Uppercase isn't unheard of on some devices.
        if file_path_is_jpeg(image_file_path) is False:
            continue

        with open(image_file_path, "rb") as image_file:
            current_image = exif.Image(image_file)
            if current_image.has_exif is False:
                secho(f"Image has no EXIF data: {image_file_path}",
                      fg="yellow", err=True)
                continue

            exif_date_taken = current_image.datetime
            taken_year, taken_month, _ =  split_exif_date_string(exif_date_taken)

            archive_file_name = f"{taken_year}/{taken_month}/{image_file_name}"
            calculated_file_names.append(
                (image_file_path, archive_file_name)
            )
    return calculated_file_names


@click.command()
@click.argument("output_file", metavar="OUTPUT_FILE",
                type=click.File("xb", lazy=True))
@click.option("--source", "-s", "source_list",
              type=str, metavar="SOURCE_PATH", multiple=True,
              default=[], show_default=False,
              help=("Specify a source of images to process. This can be a"
                    " path to either a directory or a ZIP file. Multiple "
                    "sources can be specified by using this option multiple"
                    " times."))
@click.option("--debug", "-D", "debug_flag",
              type=bool, is_flag=True,
              default=False, show_default=True,
              help=("Show additional debugging information."))
def main(output_file, source_list, debug_flag):
    """
    \033[44;37;1m PicSort \033[0m

    \b
    Sort large numbers of JPEG images into directories named by Year and
    Month that photos were taken, determined by embedded EXIF data.
    """
    directory_sources, zip_archive_sources = sort_image_sources(source_list)

    if debug_flag is True:
        secho("Directory Sources:", fg="yellow", bold=True)
        if len(directory_sources) == 0:
            secho("- None Provided -")
        else:
            for dir_source in directory_sources:
                secho(f"{dir_source}")

        secho("ZIP File Sources:", fg="yellow", bold=True)
        if len(zip_archive_sources) == 0:
            secho("- None Provided -")
        else:
            for zip_source in zip_archive_sources:
                secho(f"{zip_source}")

    if len(directory_sources) == 0 and len(zip_archive_sources) == 0:
        secho("No valid image sources were provided! Nothing to do.")
        sys.exit(1)

    archive_copy_tuples = []

    for dir_source in directory_sources:
        secho(f"Processing Directory Source: {os.path.basename(dir_source)}")
        file_copy_tuples = get_dates_from_directory_source(dir_source)
        archive_copy_tuples.extend(file_copy_tuples)

    # Create the Progress bar
    progress_bar = TextProgressBar("file", 40, 0, len(archive_copy_tuples),
                                   suffix="files")

    # Open ZIP file, create. Binary mode is implied
    with zipfile.ZipFile(output_file.name, "x") as output_zip:
        progress_bar.render()
        for file_tuple in archive_copy_tuples:
            src_file, archive_dest = file_tuple

            progress_bar.update_label(os.path.basename(src_file))
            progress_bar.render()

            output_zip.write(src_file, archive_dest)

            progress_bar.add(1)
            progress_bar.render()


if __name__ == "__main__":
    main()
